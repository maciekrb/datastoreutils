# -*- coding:utf-8 -*-
"""
Model rule matching and resolution implementation

Implementation of classes which set rules, define properties or transformations to
be generated over db.Model ndb.Model objects
"""
from google.appengine.ext import db, ndb
from collections import OrderedDict

class PropertyMap(object):

  def __init__(self):
    self._rulesets = OrderedDict()

  def match_rule(self):
    """ @TODO Rule matching logic should be placed here """
    pass

  def add_model_ruleset(self, name, ruleset):
    """
    Adds a rulset to the property map

    Args:
      - name: (str) A name for the ModelRuleSet, so it can be easily retrieved
        later by using this name
      - ruleset: (ModelRuleSet) ModelRuleSet object describing a set of rules
    """
    self._rulesets[name] = ruleset

  def get_model_ruleset(self, name):
    """
    Retrieves a ModelRuleSet by name

    Args:
      - name: (str) the name of the ruleset to retrieve

    Returns:
      ModelRuleSet object or None if no ruleset with such name is defined
    """
    return self._rulesets.get(name)

  def to_dict(self):
    """ Redefined in subclass concrete implementations """
    return [ rule.to_dict() for rule in self._rulesets.values() ]

class KeyModelMatchRule(object):
  """
  Rule that matches ndb.Key or db.Key ancestors
  """

  def __init__(self, path):
    """
    Creates an instance of a Model Match Key rule
    Args:
      - path: (db.Key, ndb.Key or list) Either a App Engine Key mode or a list
        containing tuples that can be converted into db.Model or ndb.Model keys
        i.e: (Model, id) or (Model, name). This would normally be the key of the
        parent of the records you would like to match with the rule.
    """
    self._rule = None

    if isinstance(path, ndb.Key):
      self._rule = path.pairs()
    elif isinstance(path, db.Key):
      self._rule = ndb.Key.from_old_key(path).pairs()
    elif all(isinstance(p, (tuple, list)) for p in path):
      self._rule = tuple(path)
    else:
      raise ValueError("Path should be a list of tuples (Model, id/name): {}".format(path))

  def rule(self):
    return self._rule

class PropertyModelMatchRule(object):

  def rule(self):
    #@TODO: Implement PropertyModelMatchRule
    raise NotImplemented("PropertyModelMatchRule must be implemented !!")

class ModelRuleSet(object):
  """
  Representation of rules that can be applied to a given model
  """

  def __init__(self):
    self._model_match_key_rule = None
    self._model_match_property_rules = []
    self._property_list = []
    self._modifier_groups = {}
    self._filters = []

  def set_key_rule(self, path):
    """
    Sets a model match key rule which will be used to match records

    Args:
      - path: (db.Key, ndb.Key, list) either the datastore Key of the parent or
      ancestor that should be matched by the rule or a list of tuples containing
      the model, id.
    """
    self._model_match_key_rule = KeyModelMatchRule(path)

  def get_key_rule(self):
    """ Retrieves the Key rule that will be used to match records """
    return self._model_match_key_rule

  def add_filter(self, filter):
    pass

  def add_model_property(self, attr_name):
    """
    Adds the name of a model property to the list of values to be generated

    Args:
      - args: (str) name of model attribute to be generated
    """
    if attr_name not in self._property_list:
      self._property_list.append(attr_name)

  def add_modifier_property(self, group, method, identifier, operands={}, args={}):
    """
    Adds a Modifier to the property list to be generated

    Args:
      - group: (str) name of the group to which modifier will be added. Since
        modifiers can be chained, the modifiers added to group "default" will be placed one
        chained to the next in this group.

      - method: (str) path of the modifier class. I.E:
        datastoreutils.modifiers.primitives.DateFormatModifier

      - identifier: (str) a string that will be used to address the result
        generated by the modifier in chained modifiers.

      - operands: (dict) a dictionary containing the operands to be passed to
        the FieldModifier addressed by the method argument.

      - args: (dict) a dictionary containing the args to be passed to the
        FieldModifier addressed by the method argument.
    """
    #@TODO: Check if method is callable and subclass of FieldModifier
    mod = dict(method=method, identifier=identifier, operands=operands, args=args)
    if group not in self._modifier_groups:
      self._modifier_groups[group] = list()
      self._property_list.append(self._modifier_groups[group])

    if mod not in self._modifier_groups[group]:
      self._modifier_groups[group].append(mod)

  @property
  def filters(self):
    pass

  @property
  def model_match_rule(self):
    rule = dict()
    if self._model_match_key_rule:
      rule["key"] = self._model_match_key_rule.rule()

    if self._model_match_property_rules:
      rule['properties'] = [ r.rule() for r in self._model_match_property_rules ]

    return rule

  @property
  def property_list(self):
    return self._property_list

  def to_dict(self):
    """
    Returns a dictionary representation of a DataMap
    """
    property_map = dict()
    rules = self.model_match_rule
    if rules:
      property_map["model_match_rule"] = rules

    filters = self.filters
    if filters:
      property_map["filters"] = filters

    property_map['property_list'] = self.property_list
    return property_map


